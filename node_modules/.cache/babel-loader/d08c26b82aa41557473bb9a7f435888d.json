{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Updater = void 0;\n\nconst Utils_1 = require(\"../../Utils\");\n\nconst Enums_1 = require(\"../../Enums\");\n\nclass Updater {\n  constructor(container, particle) {\n    this.container = container;\n    this.particle = particle;\n  }\n\n  update(delta) {\n    if (this.particle.destroyed) {\n      return;\n    }\n\n    this.updateOpacity(delta);\n    this.updateSize(delta);\n    this.updateAngle(delta);\n    this.updateColor(delta);\n    this.updateStrokeColor(delta);\n    this.updateOutMode(delta);\n  }\n\n  updateOpacity(delta) {\n    const particle = this.particle;\n\n    if (particle.particlesOptions.opacity.animation.enable) {\n      switch (particle.opacity.status) {\n        case Enums_1.OpacityAnimationStatus.increasing:\n          if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n          } else {\n            particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.OpacityAnimationStatus.decreasing:\n          if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n            particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n          } else {\n            particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n          }\n\n          break;\n      }\n\n      if (particle.opacity.value < 0) {\n        particle.opacity.value = 0;\n      }\n    }\n  }\n\n  updateSize(delta) {\n    var _a;\n\n    const container = this.container;\n    const particle = this.particle;\n    const sizeOpt = particle.particlesOptions.size;\n    const sizeAnim = sizeOpt.animation;\n\n    if (sizeAnim.enable) {\n      switch (particle.size.status) {\n        case Enums_1.SizeAnimationStatus.increasing:\n          if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n            particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n          } else {\n            particle.size.value += (particle.size.velocity || 0) * delta.factor;\n          }\n\n          break;\n\n        case Enums_1.SizeAnimationStatus.decreasing:\n          if (particle.size.value <= sizeAnim.minimumValue) {\n            particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n          } else {\n            particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n          }\n\n      }\n\n      switch (sizeAnim.destroy) {\n        case Enums_1.DestroyType.max:\n          if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n\n        case Enums_1.DestroyType.min:\n          if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n            particle.destroy();\n          }\n\n          break;\n      }\n\n      if (particle.size.value < 0 && !particle.destroyed) {\n        particle.size.value = 0;\n      }\n    }\n  }\n\n  updateAngle(delta) {\n    const particle = this.particle;\n    const rotateAnimation = particle.particlesOptions.rotate.animation;\n    const speed = rotateAnimation.speed / 360 * delta.factor;\n    const max = 2 * Math.PI;\n\n    if (rotateAnimation.enable) {\n      switch (particle.rotateDirection) {\n        case Enums_1.RotateDirection.clockwise:\n          particle.angle += speed;\n\n          if (particle.angle > max) {\n            particle.angle -= max;\n          }\n\n          break;\n\n        case Enums_1.RotateDirection.counterClockwise:\n        default:\n          particle.angle -= speed;\n\n          if (particle.angle < 0) {\n            particle.angle += max;\n          }\n\n          break;\n      }\n    }\n  }\n\n  updateColor(delta) {\n    const particle = this.particle;\n\n    if (particle.color === undefined) {\n      return;\n    }\n\n    if (particle.particlesOptions.color.animation.enable) {\n      particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.color.h > 360) {\n        particle.color.h -= 360;\n      }\n    }\n  }\n\n  updateStrokeColor(delta) {\n    const particle = this.particle;\n    const color = particle.stroke.color;\n\n    if (typeof color === \"string\" || color === undefined) {\n      return;\n    }\n\n    if (particle.strokeColor === undefined) {\n      return;\n    }\n\n    if (color.animation.enable) {\n      particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n\n      if (particle.strokeColor.h > 360) {\n        particle.strokeColor.h -= 360;\n      }\n    }\n  }\n\n  fixOutOfCanvasPosition() {\n    const container = this.container;\n    const particle = this.particle;\n    const wrap = particle.particlesOptions.move.warp;\n    const canvasSize = container.canvas.size;\n    const newPos = {\n      bottom: canvasSize.height + particle.size.value - particle.offset.y,\n      left: -particle.size.value - particle.offset.x,\n      right: canvasSize.width + particle.size.value + particle.offset.x,\n      top: -particle.size.value - particle.offset.y\n    };\n    const sizeValue = particle.size.value;\n    const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n\n    if (nextBounds.left > canvasSize.width - particle.offset.x) {\n      particle.position.x = newPos.left;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    } else if (nextBounds.right < -particle.offset.x) {\n      particle.position.x = newPos.right;\n\n      if (!wrap) {\n        particle.position.y = Math.random() * canvasSize.height;\n      }\n    }\n\n    if (nextBounds.top > canvasSize.height - particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.top;\n    } else if (nextBounds.bottom < -particle.offset.y) {\n      if (!wrap) {\n        particle.position.x = Math.random() * canvasSize.width;\n      }\n\n      particle.position.y = newPos.bottom;\n    }\n  }\n\n  updateOutMode(delta) {\n    const container = this.container;\n    const particle = this.particle;\n\n    switch (particle.particlesOptions.move.outMode) {\n      case Enums_1.OutMode.bounce:\n      case Enums_1.OutMode.bounceVertical:\n      case Enums_1.OutMode.bounceHorizontal:\n        this.updateBounce(delta);\n        break;\n\n      case Enums_1.OutMode.destroy:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          particle.destroy();\n          container.particles.remove(particle);\n          return;\n        }\n\n        break;\n\n      case Enums_1.OutMode.out:\n        if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n          this.fixOutOfCanvasPosition();\n        }\n\n    }\n  }\n\n  updateBounce(delta) {\n    const container = this.container;\n    const particle = this.particle;\n    let handled = false;\n\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta);\n      }\n\n      if (handled) {\n        break;\n      }\n    }\n\n    if (handled) {\n      return;\n    }\n\n    const outMode = particle.particlesOptions.move.outMode,\n          pos = particle.getPosition(),\n          offset = particle.offset,\n          size = particle.size.value,\n          bounds = Utils_1.Utils.calculateBounds(pos, size),\n          canvasSize = container.canvas.size;\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n      const velocity = particle.velocity.horizontal;\n\n      if (bounds.right >= canvasSize.width && velocity > 0 || bounds.left <= 0 && velocity < 0) {\n        particle.velocity.horizontal *= -1;\n      }\n\n      const minPos = offset.x + size;\n\n      if (bounds.right >= canvasSize.width) {\n        particle.position.x = canvasSize.width - minPos;\n      } else if (bounds.left <= 0) {\n        particle.position.x = minPos;\n      }\n    }\n\n    if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n      const velocity = particle.velocity.vertical;\n\n      if (bounds.bottom >= container.canvas.size.height && velocity > 0 || bounds.top <= 0 && velocity < 0) {\n        particle.velocity.vertical *= -1;\n      }\n\n      const minPos = offset.y + size;\n\n      if (bounds.bottom >= canvasSize.height) {\n        particle.position.y = canvasSize.height - minPos;\n      } else if (bounds.top <= 0) {\n        particle.position.y = minPos;\n      }\n    }\n  }\n\n}\n\nexports.Updater = Updater;","map":{"version":3,"sources":["/Users/riteshsharma/Face_Recognition/node_modules/tsparticles/dist/Core/Particle/Updater.js"],"names":["Object","defineProperty","exports","value","Updater","Utils_1","require","Enums_1","constructor","container","particle","update","delta","destroyed","updateOpacity","updateSize","updateAngle","updateColor","updateStrokeColor","updateOutMode","particlesOptions","opacity","animation","enable","status","OpacityAnimationStatus","increasing","decreasing","velocity","factor","minimumValue","_a","sizeOpt","size","sizeAnim","SizeAnimationStatus","sizeValue","retina","destroy","DestroyType","max","pixelRatio","min","rotateAnimation","rotate","speed","Math","PI","rotateDirection","RotateDirection","clockwise","angle","counterClockwise","color","undefined","h","colorVelocity","stroke","strokeColor","fixOutOfCanvasPosition","wrap","move","warp","canvasSize","canvas","newPos","bottom","height","offset","y","left","x","right","width","top","nextBounds","Utils","calculateBounds","position","random","outMode","OutMode","bounce","bounceVertical","bounceHorizontal","updateBounce","isPointInside","particles","remove","out","handled","plugin","plugins","particleBounce","pos","getPosition","bounds","horizontal","minPos","vertical"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Updater = void 0;\nconst Utils_1 = require(\"../../Utils\");\nconst Enums_1 = require(\"../../Enums\");\nclass Updater {\n    constructor(container, particle) {\n        this.container = container;\n        this.particle = particle;\n    }\n    update(delta) {\n        if (this.particle.destroyed) {\n            return;\n        }\n        this.updateOpacity(delta);\n        this.updateSize(delta);\n        this.updateAngle(delta);\n        this.updateColor(delta);\n        this.updateStrokeColor(delta);\n        this.updateOutMode(delta);\n    }\n    updateOpacity(delta) {\n        const particle = this.particle;\n        if (particle.particlesOptions.opacity.animation.enable) {\n            switch (particle.opacity.status) {\n                case Enums_1.OpacityAnimationStatus.increasing:\n                    if (particle.opacity.value >= particle.particlesOptions.opacity.value) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.opacity.value += (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.OpacityAnimationStatus.decreasing:\n                    if (particle.opacity.value <= particle.particlesOptions.opacity.animation.minimumValue) {\n                        particle.opacity.status = Enums_1.OpacityAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.opacity.value -= (particle.opacity.velocity || 0) * delta.factor;\n                    }\n                    break;\n            }\n            if (particle.opacity.value < 0) {\n                particle.opacity.value = 0;\n            }\n        }\n    }\n    updateSize(delta) {\n        var _a;\n        const container = this.container;\n        const particle = this.particle;\n        const sizeOpt = particle.particlesOptions.size;\n        const sizeAnim = sizeOpt.animation;\n        if (sizeAnim.enable) {\n            switch (particle.size.status) {\n                case Enums_1.SizeAnimationStatus.increasing:\n                    if (particle.size.value >= ((_a = particle.sizeValue) !== null && _a !== void 0 ? _a : container.retina.sizeValue)) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.decreasing;\n                    }\n                    else {\n                        particle.size.value += (particle.size.velocity || 0) * delta.factor;\n                    }\n                    break;\n                case Enums_1.SizeAnimationStatus.decreasing:\n                    if (particle.size.value <= sizeAnim.minimumValue) {\n                        particle.size.status = Enums_1.SizeAnimationStatus.increasing;\n                    }\n                    else {\n                        particle.size.value -= (particle.size.velocity || 0) * delta.factor;\n                    }\n            }\n            switch (sizeAnim.destroy) {\n                case Enums_1.DestroyType.max:\n                    if (particle.size.value >= sizeOpt.value * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n                case Enums_1.DestroyType.min:\n                    if (particle.size.value <= sizeAnim.minimumValue * container.retina.pixelRatio) {\n                        particle.destroy();\n                    }\n                    break;\n            }\n            if (particle.size.value < 0 && !particle.destroyed) {\n                particle.size.value = 0;\n            }\n        }\n    }\n    updateAngle(delta) {\n        const particle = this.particle;\n        const rotateAnimation = particle.particlesOptions.rotate.animation;\n        const speed = (rotateAnimation.speed / 360) * delta.factor;\n        const max = 2 * Math.PI;\n        if (rotateAnimation.enable) {\n            switch (particle.rotateDirection) {\n                case Enums_1.RotateDirection.clockwise:\n                    particle.angle += speed;\n                    if (particle.angle > max) {\n                        particle.angle -= max;\n                    }\n                    break;\n                case Enums_1.RotateDirection.counterClockwise:\n                default:\n                    particle.angle -= speed;\n                    if (particle.angle < 0) {\n                        particle.angle += max;\n                    }\n                    break;\n            }\n        }\n    }\n    updateColor(delta) {\n        const particle = this.particle;\n        if (particle.color === undefined) {\n            return;\n        }\n        if (particle.particlesOptions.color.animation.enable) {\n            particle.color.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.color.h > 360) {\n                particle.color.h -= 360;\n            }\n        }\n    }\n    updateStrokeColor(delta) {\n        const particle = this.particle;\n        const color = particle.stroke.color;\n        if (typeof color === \"string\" || color === undefined) {\n            return;\n        }\n        if (particle.strokeColor === undefined) {\n            return;\n        }\n        if (color.animation.enable) {\n            particle.strokeColor.h += (particle.colorVelocity || 0) * delta.factor;\n            if (particle.strokeColor.h > 360) {\n                particle.strokeColor.h -= 360;\n            }\n        }\n    }\n    fixOutOfCanvasPosition() {\n        const container = this.container;\n        const particle = this.particle;\n        const wrap = particle.particlesOptions.move.warp;\n        const canvasSize = container.canvas.size;\n        const newPos = {\n            bottom: canvasSize.height + particle.size.value - particle.offset.y,\n            left: -particle.size.value - particle.offset.x,\n            right: canvasSize.width + particle.size.value + particle.offset.x,\n            top: -particle.size.value - particle.offset.y,\n        };\n        const sizeValue = particle.size.value;\n        const nextBounds = Utils_1.Utils.calculateBounds(particle.position, sizeValue);\n        if (nextBounds.left > canvasSize.width - particle.offset.x) {\n            particle.position.x = newPos.left;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        else if (nextBounds.right < -particle.offset.x) {\n            particle.position.x = newPos.right;\n            if (!wrap) {\n                particle.position.y = Math.random() * canvasSize.height;\n            }\n        }\n        if (nextBounds.top > canvasSize.height - particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.top;\n        }\n        else if (nextBounds.bottom < -particle.offset.y) {\n            if (!wrap) {\n                particle.position.x = Math.random() * canvasSize.width;\n            }\n            particle.position.y = newPos.bottom;\n        }\n    }\n    updateOutMode(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        switch (particle.particlesOptions.move.outMode) {\n            case Enums_1.OutMode.bounce:\n            case Enums_1.OutMode.bounceVertical:\n            case Enums_1.OutMode.bounceHorizontal:\n                this.updateBounce(delta);\n                break;\n            case Enums_1.OutMode.destroy:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    particle.destroy();\n                    container.particles.remove(particle);\n                    return;\n                }\n                break;\n            case Enums_1.OutMode.out:\n                if (!Utils_1.Utils.isPointInside(particle.position, container.canvas.size, particle.size.value)) {\n                    this.fixOutOfCanvasPosition();\n                }\n        }\n    }\n    updateBounce(delta) {\n        const container = this.container;\n        const particle = this.particle;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const outMode = particle.particlesOptions.move.outMode, pos = particle.getPosition(), offset = particle.offset, size = particle.size.value, bounds = Utils_1.Utils.calculateBounds(pos, size), canvasSize = container.canvas.size;\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceHorizontal) {\n            const velocity = particle.velocity.horizontal;\n            if ((bounds.right >= canvasSize.width && velocity > 0) || (bounds.left <= 0 && velocity < 0)) {\n                particle.velocity.horizontal *= -1;\n            }\n            const minPos = offset.x + size;\n            if (bounds.right >= canvasSize.width) {\n                particle.position.x = canvasSize.width - minPos;\n            }\n            else if (bounds.left <= 0) {\n                particle.position.x = minPos;\n            }\n        }\n        if (outMode === Enums_1.OutMode.bounce || outMode === Enums_1.OutMode.bounceVertical) {\n            const velocity = particle.velocity.vertical;\n            if ((bounds.bottom >= container.canvas.size.height && velocity > 0) || (bounds.top <= 0 && velocity < 0)) {\n                particle.velocity.vertical *= -1;\n            }\n            const minPos = offset.y + size;\n            if (bounds.bottom >= canvasSize.height) {\n                particle.position.y = canvasSize.height - minPos;\n            }\n            else if (bounds.top <= 0) {\n                particle.position.y = minPos;\n            }\n        }\n    }\n}\nexports.Updater = Updater;\n"]},"metadata":{},"sourceType":"script"}